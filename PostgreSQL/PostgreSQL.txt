Que es Postgres 
    Es un motor de base de datos 
    - Open Sourse
    - Objeto-Relacional
    - Usa SQL

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Instalación y configuración
    Vamos a instalar PostgreSQL en nuestra computadora. A continuación veremos el paso a paso y algunos 
    consejos útiles para instalar y configurar correctamente PostgreSQL en nuestro equipo. 
    En éste caso, usaremos Windows, pero los pasos son bastante similares entre los diferentes sistemas 
    operativos.

        Primer paso: ir a https://www.postgresql.org/.

        Ten en cuenta que puedes ver esta página en diferentes idiomas, depende de la configuración 
        predeterminada de idioma de tu navegador.
        Hacer clic en el botón ‘Download’ (Descarga) que se encuentra en la parte inferior derecha. 
           
        Seleccionamos la opción que corresponda con tu sistema operativo, para éste caso hacemos 
        clic en “Windows”:

        Haz clic en el enlace “Download the installer”. Esto nos va a llevar a la Web de Enterprise DB 
        o EDB. EDB es una empresa que ofrece servicios sobre el motor de base de datos PostgreSQL y 
        ofrece un instalador para Postgres de manera gratuita.

        Es altamente recomendable seleccionar la penúltima o antepenúltima versión. Si bien la última 
        versión estable está disponible, en éste caso la 12.0, no es recomendable instalarla en nuestro 
        equipo, ya que al momento de instalarla o usar un servicio en la Nube para Postgres, 
        lo más seguro es que no esté disponible y sólo esté hasta la versión 11.5, que no es la 
        última versión. Esto porque todos los proveedores de Infraestructura no disponen de la 
        versión de Postgres más actual siempre (tardan un poco en apropiar los nuevos lanzamientos).


        Si tienes un equipo con Linux, la instalación la puedes hacer directamente desde los repositorios 
        de Linux, EDB ya no ofrece soporte para instaladores en Linux debido a que se ha vuelto 
        innecesario, el repositorio de Linux con PostgreSQL ofrece una manera mucho más sencilla y 
        estándar para instalar PostgreSQL en linux.

        Segundo paso: descargamos la versión “Windows x86-64” (porque nuestro sistema operativo es de 64 
        bits). En caso de que tu equipo sea de 32 bits debes seleccionar la opción “Windows x86-32”.

        Vamos a descargar la versión 11.5. Hacemos clic en Download y guardamos el archivo que tendrá un 
        nombre similar a:
        “postgresql-11.5-2-windows-x64.exe”

        Ahora vamos a la carpeta donde descargamos el archivo .exe, debe ser de aproximadamente 190 MB, 
        lo ejecutamos.

        Seleccionamos los servicios que queremos instalar. En este caso dejamos seleccionados todos menos 
        “Stack Builder”, pues ofrece la instalación de servicios adicionales que no necesitamos hasta 
        ahora. Luego hacemos clic en siguiente:

        Ahora indicamos la carpeta donde iran guardados los datos de la base de datos, es diferente a la 
        ruta de instalación del Motor de PostgreSQL, pero normalmente será una carpeta de nuestra carpeta 
        de instalación. Puedes cambiar la ruta si quieres tener los datos en otra carpeta. 
        Hacemos clic en siguiente.

        Ingresamos la contraseña del usuario administrador. De manera predeterminada, 
        Postgres crea un usuario super administrador llamado postgres que tiene todos los permisos y 
        acceso a toda la base de datos, tanto para consultarla como para modificarla. 
        En éste paso indicamos la clave de ese usuario super administrador.

        Debes ingresar una clave muy segura y guardarla porque la vas a necesitar después. 
        Luego hacemos clic en siguiente.

        Ahora si queremos cambiar el puerto por donde el servicio de Postgresql estará escuchando 
        peticiones, podemos hacerlo en la siguiente pantalla, si queremos dejar el predeterminado 
        simplemente hacemos clic en siguiente.

        La configuración regional puede ser la predeterminada, no es necesario cambiarla, 
        incluso si vamos a usarla en español, ya que las tildes y las eñes estarán soportadas si 
        dejas la configuración regional predeterminada. Es útil cambiarla cuando quieras dejar de 
        soportar otras funciones de idiomas y lenguajes diferentes a uno específico. 
        Luego hacemos clic en siguiente:

        En pantalla aparecerá el resumen de lo que se va a instalar:

        Al hacer clic en siguiente se muestra una pantalla que indica que PostgreSQL está listo 
        para instalar, al hacer clic de nuevo en siguiente iniciará la instalación, 
        espera un par de minutos hasta que la aplicación termine.

        Una vez terminada la instalación, aparecerá en pantalla un mensaje mostrando que PostgreSQL 
        ha sido instalado correctamente.

        Podemos cerrar ésta pantalla y proceder a comprobar que todo quedó instalado correctamente.

        Vamos a buscar el programa PgAdmin, el cual usaremos como editor favorito para ejecutar en él 
        todas las operaciones sobre nuestra base de datos.

        También vamos a buscar la consola… Tanto la consola como PgAdmin son útiles para gestionar 
        nuestra base de datos, una nos permite ingresar comando por comandos y la otra nos 
        ofrece una interfaz visual fácil de entender para realizar todas las operaciones.

        En el menú de Windows (o donde aparecen instalados todos los programas) buscamos 
        “PgAdmin…”

        Ahora buscamos “SQL Shell…”

        Efectivamente, ahora aparecen las herramientas que vamos a utilizar en éste curso.

        Ahora vamos a crear una base de datos de prueba usando la consola y comprobaremos si existe 
        usando PgAdmin, la crearemos para validar que la conexión con el servicio de base de datos 
        interno funciona correctamente.

        Para ello abrimos la consola, buscamos SQL Shell y lo ejecutamos.

        Lo que vemos en pantalla es la consola esperando que ingresemos cada parámetro para la conexión.

        Primero está el nombre del parámetro. En éste caso es “Server” seguido de unos corchetes que 
        contienen el valor predeterminado. Si presionamos “Enter” sin digitar nada la consola 
        asumirá que te refieres al valor predeterminado, si en éste caso presionamos “Enter” 
        el valor asumido será “Localhost”. Localhost se refiere a nuestra propia máquina, 
        si instalaste la base de datos en el mismo pc que estás usando para la consola, 
        el valor correcto es Localhost o 127.0.0.1 (representan lo mismo).

        Podemos dejar todos los valores predeterminados (presionando “Enter”) 
        hasta que la consola pregunte por la clave del usuario maestro:

        Debemos ingresar la clave que usamos cuando estábamos instalando Postgres, de lo contrario no 
        podremos acceder. Presionamos Enter y veremos a continuación una pantalla que nos 
        indica que estamos logueados en la base de datos y estamos listos para hacer modificaciones.

        De manera predeterminada, la base de datos instalada es Postgres, la cual no debemos tocar, 
        ya que ejecuta funciones propias del motor. Es usada por el Motor de PostgreSQL para interactuar 
        con todas las bases de datos que vayamos a crear en el futuro.

        La siguiente imagen indica que estamos conectados a la base de datos Postgres. 
        Vamos a crear una base de datos nueva y luego saltar el cursor a ésta base de datos 
        recién creada.

        Para ello escribimos el comando “CREATE DATABASE transporte_publico;” 
        y presionamos “Enter”.

        El mensaje “CREATE DATABASE” justo después de la línea que acabamos de escribir 
        indica que la base de datos fue creada correctamente.

        Para saltar a la base de datos recién creada ejecutamos el comando “\c transporte_publico”

        Ahora vamos a validar desde PgAdmin que la base de datos fué creada correctamente. 
        Abrimos PgAdmin y nos encontramos con una lista de items a la izquierda, lo que significa 
        que de manera predeterminada PgAdmin ha creado un acceso a nuestra base de datos local, 
        el cual llamó “PostgreSQL 11”: 

        Al hacer hacer doble clic sobre éste elemento (“PostgreSQL 11”) nos pedirá ingresar la 
        clave que hemos determinado para el super usuario postgres, al igual que la consola, 
        hasta no ingresarla correctamente no nos podremos conectar:

        Ingresamos la clave. Te recomiendo seleccionar la opción “Save Password” o “Guardar Contraseña”. 
        Si la máquina sobre la que estás trabajando es de confianza, que seas sólo tú o tu equipo quien 
        tenga acceso a ella, de lo contrario, no guardes la contraseña para mantenerla segura.
        
        Veremos la lista de bases de datos disponibles, la predeterminada “postgres” y la que acabamos 
        de crear usando la consola, lo que comprueba que la base de datos y la consola funcionan 
        correctamente.

        Ahora procedemos a eliminar la base de datos recién creada para comprobar que PgAdmin está 
        correctamente configurada y si pueda realizar cambios sobre la base de datos.

        Para ello hacemos clic derecho sobre el elemento “transporte_publico” y seleccionamos la opción 
        “Delete/Drop”. Al mensaje de confirmar hacemos clic en OK.

        Con ello, si el elemento “transporte_publico” desaparece del menú de la izquierda 
        comprobamos que PgAdmin funcionan correctamente.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Como conecterse a la base de datos desde la consola 

    Server (Localhost): Numero de ip o nombre de dominio si no es tu pc
    Datebase [postgres]: Para cambiar la base de datos que esta por defecto ingresa la base de datos
                         a la cual quieres ingresar
    Port [5432]: si quieres cambiar el puerto por seguridad aqui los puedes hacer 
    Username [postgres]: Ingrese el nombre de usuario si no es el que se encuentra por defecto
    Password for user postgres: ingrese la contraseña 

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Comandos de Postgres
    SELECT version();               -> Consultamos la version de postgres que esta instalada
    \h                              -> Muestra todos los comandos de SQL que se pueden usar en postgres
    \h ComandoSQl                   -> Muestra todo lo que se puede hacer con ese comando
    Comandos de navegación y consulta de información
            \?                      -> Muestra todos los comandos
            \l                      -> Lista todas las bases de datos que tenemos instaladas
            
            \dt                     -> Muestra las tablas que tiene la base de datos de postgres 
            \d nombreTabla          -> Consultamos la tabla de la base de datos
            \df                     -> listar las funciones disponibles de la base de datos actual  
            \dn                     -> Listar los esquemas de la base de datos actual  
            \dv                     -> Listar vistas de la base de datos actual
            \du                     -> listar los usuarios y sus roles de la base de datos actual
            
            \c nombreBasedatos      -> Cambia de base de datos  

    Comandos de inspección y ejecución            
            \g                      -> Permite volver a ejecutar la misma funcion que acabas de ejecutar en la 
                                    consola
            \s                      -> Ver el historial de comandos ejecutados
            \s NombreArchivo        -> Si se quiere guardar la lista de comandos ejecutados en un 
                                       archivo de texto plano

            \i NombreArchivo        -> Ejecuta los comandos desde un archivo

            \e                      -> Permite abrir un editor de texto plano, escribir comandos y ejecutar 
                                       en lote. \e abre el editor de texto, escribir allí todos los comandos, 
                                       luego guardar los cambios y cerrar, al cerrar se ejecutarán todos los 
                                       comandos guardados.
            \ef                     -> Equivalente al comando anterior pero permite editar también 
                                       funciones en PostgreSQL

        Comandos para debug y optimización
            \timing                 -> Muestra el tiempo en el que se ejecuto una consulta en la base de 
                                        datos 
            
        Comandos para cerrar la consola
            \q Cerrar la consola

        Ejecutando consultas en la base de datos usando la consola
            De manera predeterminada PostgreSQL no crea bases de datos para usar, debemos crear nuestra 
            base de datos para empezar a trabajar, verás que existe ya una base de datos llamada postgres 
            pero no debe ser usada ya que hace parte del CORE de PostgreSQL y sirve para gestionar 
            las demás bases de datos.

            Para crear una base de datos debes ejecutar la consulta de creación de base de datos, 
            es importante entender que existe una costumbre no oficial al momento de escribir consultas; 
            consiste en poner en mayúsculas todas las palabras propias del lenguaje SQL cómo CREATE, 
            SELECT, ALTE, etc y el resto de palabras como los nombres de las tablas, columnas, 
            nombres de usuarios, etc en minúscula. No está claro el porqué de esta especie de “estándar” 
            al escribir consultas SQL pero todo apunta a que en el momento que SQL nace, no existían 
            editores de consultas que resaltaran las palabras propias del lenguaje para diferenciar 
            fácilmente de las palabras que no son parte del lenguaje, por eso el uso de mayúsculas y 
            minúsculas.

            Las palabras reservadas de consultas SQL usualmente se escriben en mayúscula, ésto para 
            distinguir entre nombres de objetos y lenguaje SQL propio, no es obligatorio, pero podría 
            serte útil en la creación de Scripts SQL largos.

            Vamos ahora por un ligero ejemplo desde la creación de una base de datos, la creación de una 
            tabla, la inserción, borrado, consulta y alteración de datos de la tabla.

            Primero crea la base de datos, “CREATE DATABASE transporte;” sería el primer paso.

            Ahora saltar de la base de datos postgres que ha sido seleccionada de manera predeterminada a 
            la base de datos transporte recién creada utilizando el comando \c transporte.

            Ahora vamos a crear la tabla tren, el SQL correspondiente sería:
                CREATE TABLE tren ( id serial NOT NULL, modelo character varying, capacidad integer, 
                CONSTRAINT tren_pkey PRIMARY KEY (id) );

            La columna id será un número autoincremental (cada vez que se inserta un registro se 
            aumenta en uno), modelo se refiere a una referencia al tren, capacidad sería la cantidad de 
            pasajeros que puede transportar y al final agregamos la llave primaria que será id.

            Ahora que la tabla ha sido creada, podemos ver su definición utilizando el comando \d tren

            PostgreSQL ha creado el campo id automáticamente cómo integer con una asociación predeterminada 
            a una secuencia llamada ‘tren_id_seq’. De manera que cada vez que se inserte un valor, id tomará 
            el siguiente valor de la secuencia, vamos a ver la definición de la secuencia. Para ello, \d 
            tren_id_seq es suficiente:

            Vemos que la secuencia inicia en uno, así que nuestra primera inserción de datos dejará a la 
            columna id con valor uno.
                INSERT INTO tren( modelo, capacidad ) VALUES (‘Volvo 1’, 100);

            Consultamos ahora los datos en la tabla:
                SELECT * FROM tren;

            Vamos a modificar el valor, establecer el tren con id uno que sea modelo Honda 0726. 
            Para ello ejecutamos la consulta tipo UPDATE tren 
                SET modelo = 'Honda 0726' Where id = 1;

            Verificamos la modificación 
                SELECT * FROM tren;

            Ahora borramos la fila: 
                DELETE FROM tren WHERE id = 1;    

            Verificamos el borrado 
                SELECT * FROM tren;    

            El borrado ha funcionado tenemos 0 rows, es decir, no hay filas. Ahora activemos la herramienta que 
            nos permite medir el tiempo que tarda una consulta 
                \timing

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Archivos de configuracion
    Para emcontrarlos 
        Entramos a PgAdmin -> SHOW config_file;
        Muestra la ruta 

    - postgresql.conf   -> Es donde se hace el registro de cuales son las QUERYS mas lentas
                           donde podemos crear duplicados de las bases de datos
    - pg_hba.conf       -> Muestra los roles y tipos de acceso que tienen las bases de datos
    - pg_ident.conf     -> Permite a que usuario tiene cada rol  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////    

Tipos de datos 
    https://www.todopostgresql.com/postgresql-data-types-los-tipos-de-datos-mas-utilizados/

    Name	                                    Aliases	                Description
    bigint	                                    int8	                signed eight-byte integer
    bigserial	                                serial8	                autoincrementing eight-byte integer
    bit [ (n) ]	 	                                                    fixed-length bit string
    bit varying [ (n) ]	                        varbit [ (n) ]	        variable-length bit string
    boolean	                                    bool	                logical Boolean (true/false)
    box	 	                                                            rectangular box on a plane
    bytea	 	                                                        binary data (“byte array”)
    character [ (n) ]	                        char [ (n) ]	        fixed-length character string
    character varying [ (n) ]	                varchar [ (n) ]	        variable-length character string
    cidr	 	                                                        IPv4 or IPv6 network address
    circle	 	                                                        circle on a plane
    date	 	                                                        calendar date (year, month, day)
    double precision	                        float8	                double precision floating-point 
                                                                        number (8 bytes)
    inet	 	                                                        IPv4 or IPv6 host address
    integer	                                    int, int4               signed four-byte integer
    interval [ fields ] [ (p) ]	 	                                    time span
    json	 	                                                        textual JSON data
    jsonb	 	                                                        binary JSON data, decomposed
    line	 	                                                        infinite line on a plane
    lseg	 	                                                        line segment on a plane
    macaddr	 	                                                        MAC (Media Access Control) address
    macaddr8	 	                                                    MAC (Media Access Control) address 
                                                                        (EUI-64 format)
    money	 	                                                        currency amount
    numeric [ (p, s) ]	                        decimal [ (p, s) ]      exact numeric of selectable     
                                                                        precision
    path	 	                                                        geometric path on a plane
    pg_lsn	 	                                                        PostgreSQL Log Sequence Number
    point	 	                                                        geometric point on a plane
    polygon	 	                                                        closed geometric path on a plane
    real	                                    float4	                single precision floating-point 
                                                                        number (4 bytes)
    smallint	                                int2	                signed two-byte integer
    smallserial	                                serial2	                autoincrementing two-byte integer
    serial	                                    serial4	                autoincrementing four-byte integer
    text	 	                                                        variable-length character string
    time [ (p) ] [ without time zone ]	 	                            time of day (no time zone)
    time [ (p) ] with time zone	                 timetz	                time of day, including time zone
    timestamp [ (p) ] [ without time zone ]     	 	                date and time (no time zone)
    timestamp [ (p) ] with time zone	         timestamptz	        date and time, including time zone
    tsquery	 	                                                        text search query
    tsvector	 	                                                    text search document
    txid_snapshot	 	                                                user-level transaction ID snapshot
    uuid	 	                                                        universally unique identifier
    xml	 	                                                            XML data

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Jerarquía de Bases de Datos

    Toda jerarquía de base de datos se basa en los siguientes elementos:

        Servidor de base de datos: Computador que tiene un motor de base de datos instalado y en ejecución.

        Motor de base de datos: Software que provee un conjunto de servicios encargados de administrar 
                                una base de datos.

        Base de datos: Grupo de datos que pertenecen a un mismo contexto.

        Esquemas de base de datos en PostgreSQL: Grupo de objetos de base de datos que guarda relación  
                                                entre sí (tablas, funciones, relaciones, secuencias).

        Tablas de base de datos: Estructura que organiza los datos en filas y columnas formando una matriz.

    PostgreSQL es un motor de base de datos.

        La estructura de la base de datos diseñada para el reto corresponde a los siguientes
        elementos:

            La base de datos se llama transporte, usaremos su esquema predeterminado public.

                El esquema public contiene las siguientes tablas:

                    - Estación: Contiene la información de las estaciones de nuestro sistema, incluye 
                                datos de nombre con tipo de dato texto y dirección con tipo de dato 
                                texto, junto con un número de identificación único por estación. 

                    - Pasajero: Es la tabla que contiene la información de las personas que viajan en 
                                nuestro sistema de transporte masivo, sus columnas son nombre tipo de 
                                dato texto con el nombre completo de la persona, direccion_residencia 
                                con tipo de dato texto que indica dónde vive la persona, fecha_nacimiento 
                                tipo de dato texto y un ID único tipo de dato numérico para identificar a 
                                cada persona.

                    - Tren:     Almacena la información de los trenes de nuestro sistema, cada tren 
                                tiene un modelo con tipo de dato texto y una capacidad con tipo de 
                                dato numérico que representa la cantidad de personas que puede llevar 
                                ese tren, también tiene un ID único por tren.

                Y las tablas de relaciones entre cada uno de los elementos anteriores son:

                    - Trayecto: Relaciona los trenes con las estaciones, simula ser las rutas que cada 
                                uno de los trenes pueden desarrollar entre las estaciones

                    - Viaje:    Relaciona Trayecto con Pasajero ilustrando la dinámica entre los viajes 
                                que realizan las personas, los cuales parten de una estación y se hacen 
                                usando un tren.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Acciones
    CREATE  -> Sirve para inicializar una sin ningun tipo de dato
    ALTER   -> Sirve para agregar columnas o eliminar columnas cambiar indices 
    DROP    -> Permite crear una tabla
    
    Create (Database , Table, view)

            Para crear una base de datos 
                CREATE DATEBASE Nombre_base_datos; o CREATE SCHEMA Nombre_base_datos;

            Para utilizar esta Base de datos por default     
                USE DATEBASE Nombre_base_datos;
             
            Para crear una tabla 
                CREATE TABLE 'Nombre_base_datos'. 'Nombre_tabla'(
                    Dato_1 int,
                    Dato_2 varchar (255)
                );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Particiones
    - Consiste en una separacion fisica de datos 
    - Estructura logica 
    
    Simulacion de creacion
        - Se crea una nueva tabla 

        - cambiamos en general Partioned table? a yes 

        - Agregamos campos normales sin primary key ya que nos es posible crear particiones con una primary key 
        
        - Vamos a pa pestaña particion y elegimos el tipo de particion

        - Agregamos la llave por la cual vamos a hacer la particion (Partition key)

        - Luego de haberla creado hacemos 
            CREATE TABLE nombreDeLaTablaParticionDato PARTITION nombreDeLaTablaParticion 
            FOR VALUES FROM ('datos') to ('datos');

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Roles 
    Pueden 
        - Crear y eliminar
        - Asignar atributos
        - Agrupar con otros roles
        - Roles predeterminados

    Para saber que caracteristicas tiene cada rol por consola
    \h CREATE ROLE    

/////////////////////////////////////////////////////////////////////////////////////////////////////////////    

Caracteristicas de los roles
    Rol de solo lectura
        El primer paso consiste en crear un nuevo rol denominado readonly mediante la siguiente 
        instrucción SQL:
            CREATE ROLE readonly;

        Este es un rol simple sin permisos ni contraseña. No se puede utilizar para iniciar 
        sesión en la base de datos.
        
        Conceda permiso a este rol para conectarse a la base de datos de destino denominada 
        “mydatabase”:
           GRANT CONNECT ON DATABASE mydatabase TO readonly;

        El siguiente paso es otorgar acceso al uso de este rol a su esquema. Supongamos que 
        el esquema se llama myschema:
            GRANT USAGE ON SCHEMA myschema TO readonly;

        En este paso se concede permiso de rol de readonly para realizar alguna actividad 
        dentro del esquema. Sin este paso, el rol readonly no puede realizar ninguna acción 
        en los objetos de este esquema, incluso si se han concedido permisos para esos objetos.

        El siguiente paso consiste en otorgar acceso al rol readonly para ejecutar las consultas 
        en las tablas requeridas.
            GRANT SELECT ON TABLE mytable1, mytable2 TO readonly;

        Si el requisito es conceder acceso a todas las tablas y vistas del esquema, puede 
        utilizar el siguiente SQL:
            GRANT SELECT ON ALL TABLES IN SCHEMA myschema TO readonly;

        La instrucción SQL anterior otorga acceso SELECT al rol de solo lectura en todas las 
        tablas y vistas existentes en el esquema llamado myschema. Tenga en cuenta que el 
        usuario readonly no podrá acceder a las tablas nuevas que se añadan en el futuro. 
        Para garantizar que también se pueda acceder a nuevas tablas y vistas, ejecute la 
        siguiente instrucción para conceder permisos automáticamente:
            ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO readonly;

        

    Rol de lectura y escritura
        El proceso de agregar un rol de lectura/escritura es muy similar al proceso de rol
        de solo lectura que se trató anteriormente. El primer paso es crear un rol:
            CREATE ROLE readwrite;

        Conceda permiso a este rol para conectarse a la base de datos de destino:
            GRANT CONNECT ON DATABASE mydatabase TO readwrite;

        Conceda privilegio de uso de esquemas:
            GRANT USAGE ON SCHEMA myschema TO readwrite;

        Si desea permitir que este rol cree nuevos objetos como tablas de este esquema, 
        utilice el siguiente SQL en lugar del anterior:
            GRANT USAGE, CREATE ON SCHEMA myschema TO readwrite;

        El siguiente paso es conceder acceso a las tablas. Como se mencionó en la sección 
        anterior, la concesión puede realizarse en tablas individuales o en todas las 
        tablas del esquema. Para tablas individuales, utilice el siguiente SQL:
            GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE mytable1, mytable2 TO readwrite;

        Para todas las tablas y vistas del esquema, utilice el siguiente SQL:
            GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA myschema TO readwrite;

        Para conceder automáticamente permisos sobre tablas y vistas añadidas en el futuro:
            ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT, INSERT, UPDATE, 
            DELETE ON TABLES TO readwrite;

        Para los roles de lectura y escritura, normalmente existe el requisito de utilizar secuencias 
        también. Puede dar acceso selectivo de la siguiente manera:
            GRANT USAGE ON SEQUENCE myseq1, myseq2 TO readwrite;

        También puede conceder permiso a todas las secuencias mediante la siguiente instrucción SQL:
            GRANT USAGE ON ALL SEQUENCES IN SCHEMA myschema TO readwrite;

        Para conceder permisos automáticamente a las secuencias añadidas en el futuro:
            ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT USAGE ON SEQUENCES TO readwrite;

        Puede conceder más o menos permisos en función de los requisitos. La documentación 
        del comando GRANT de PostgreSQL proporciona más detalles sobre los objetos en 
        los que se pueden conceder permisos y las sentencias SQL necesarias.
       
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Creacion, Edicion, eliminacion de roles por consola

    CREAR ROLES 
        CREATE ROLE nombredeusuario
        WITH caracteristicas;
    -----------------------------------------------------------------------------------------------------------------

    Crear contraseña en un rol 
        CREATE ROLE nombredeusuario
        WITH LOGIN;
        
        ALTER ROLE nombredeusuario LOGIN PASSWORD 'contraseña' ;
    -------------------------------------------------------------------------------------------------------------------

    Modificar roles
        ALTER ROLE nombredeusuario
        WITH caracteristicas;
    -------------------------------------------------------------------------------------------------------------------
    Borrar usuario     

        DROP ROLE nombredeusuario;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Creacion de roles por PgAdmin
    Buscamos Login/Grup Role
        - click derecho Create 
        - Login/Grup Role
            General 
                - En Name       (Usuario)
                - En Comments   (escribimos lo que hace el usuario)   opcional
            Definition 
                - En Password   (contraseña)
                
            Privilegies         (podemos ver todos los atributos)
                - Cambiamos cada una de las opciones que el usuario puede hacer

            Membership
                - Si hemos creado un grupo de permisos podemos asigmarlo para el usuario 

            Parameters
                - Podemos caracterizar variables y atributos en la base de datos 

    Buscamos Tables
        - Click derecho
        - Grand Wizard 
            Pregunta que tablas queremos afectar 
            - Next
                - Seleccionamos los permisos que le amos a dar al Usuario
                    - Hacemos click en el +
                    - Grantee   (seleccionamos el usuario al que le vamos a dar los permisos)
                    - Privileges (Seleccionamos los privilegios)
                    Finish

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Llaves foraneas
    Tiene
        - Tabla origen 
        - Tabla destino
        - Acciones

    - Buscamos la tabla a la cual queremos insertar una tabla foraneas
    - Click derecho propiedades 
        - Constraints
            - Foreign key 
            - Seleccionamos +
            - Name (nombreTablaOrigen_NombreTablaDestino_fkey)
            - Add new 
                - General 
                     Name ()
                - Definition (Podemos agregar caracterristicas especiales para validacion de Backup)
                    - Deferrable            -> Podemos aplazar
                    - Deferred              -> Apenas la creemos no se va a validar 
                    - Match type            -> Que la comparacion entre comunas va ha ser de valor 
                                               a valor (simple), si tenemos otro valor tiene que ser compleja (full)
                    - Validated             -> Que tenemos que iniciar las tablas con la validacion   
                - Columns
                    - Local column  (es la columna a la cual estamos haciendo referencia)
                    - References    (La tabla a la cual esta haciendo referencia)
                    - Referencing   (la columla de la tabla a la cual esta haciendo referencia)
                - Action (que tiene que hacer la base de datos cuando ocurre un cambio)
                    - On update (Se actualiza)
                        - NO ACTION     -> No hace nada
                        - RESTRICT      -> Que la tabla no pueda hacer cambios
                        - CASCADE       -> Si cambia la tabla de origen la tabla destino tambien cambia 
                        - SET NULL      -> Cambia la informacion que teniamos por null 
                        - SET DEFAULT   -> La tabla toma un vlor predeterminado
                    - On delete (Se borra)
                        - NO ACTION     ->
                        - RESTRICT      ->
                        - CASCADE       ->
                        - SET NULL      ->
                        - SET DEFAULT   ->

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Insertar datos
    INSERT INTO public.nombreTabla(
        CombreColumna1, nombrecolumna2)
        VALUES (valorColumna1 , 'valorColumna2');

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Actualizamos datos 
    UPDATE public.nombreTabla
        SET CombreColumna1 = valorCambiado, nombrecolumna2=ValorCambiado)
        Set id = 1
        WHERE (condicion) id = 2;

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Borrar datos 
    DELETE FROM public.nombreTabla
    WHERE (condicion) id = 1 ;

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Cruzar tablas 
    Tipos de JOIN
        - JOIN (INNER)      ->  Permite consultar la interseccion
        - LEFT [OUTER]      ->  Permite consultar la izquierda
        - RIGTH [OUTER]     ->  Permite consultar la derecha 
        - FULL OUTER        ->  Permite consultar todo 
        https://upload.wikimedia.org/wikipedia/commons/c/c9/Joins_del_SQL.svg

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Funciones especiales principales 
    - ON CONFLICT DO    -> Nos ayuda cuando queremos insertar o modificar datos que no podamos
        - Si queremos reemplar la el valor de una columna y hay un conflicto
            INSERT TO public.nombreTabla(
            nombreColumna1, nombrecolumna2)
            Values (valorColumna1, valorColumna2)
            ON CONFLICT (NombreColumnaConflicto) DO UPDATE SET nombrecolumna2 = valorColumna2;

        - Si no queremos reemplazar los datos de la columna     
            INSERT TO public.nombreTabla(
            nombreColumna1, nombrecolumna2)
            Values (valorColumna1, valorColumna2)
            ON CONFLICT (NombreColumnaConflicto) DO NOTHING;

    - RETURNING         -> Devuelve todos los cambios que hemos hecho sobre la base de datos
        - Si queremos poder ver lo que acabanos de insertar
            INSERT TO public.nombreTabla(
            nombreColumna1, nombrecolumna2)
            Values (valorColumna1, valorColumna2)
            RETURING *;

    - LIKE / ILIKE      -> Permite hacer busquedas
        - LIKE  -> Tiene en cuenta las mayusculas
        - ILIKE -> No tiene en cuenta las mayuculas o las minusculas
        - Si un registro comienza con o 
            SELECT nombreColumna
                FROM public.nombreTabla
                WHERE nombreColumna LIKE 'o%';
                
    - IS / IS NOT       -> permite comparar 2 datos 
        - Que registros son NULL 
            SELECT nombreColumna
                FROM public.nombreTabla
                WHERE nombreColumna IS NULL;

        - Que registros son NOT NULL 
            SELECT nombreColumna
                FROM public.nombreTabla
                WHERE nombreColumna IS NOT NULL;        

////////////////////////////////////////////////////////////////////////////////////////////////////////////

Funciones especiales avanzadas
    - COALESCE              -> Permite comparar 2 valores y retormar cual de los 2 no es NULL
        - Si el dato con id = 1 en nombreColumna1 es NULL se colocara no aplica
            SELECT id COALESE (nombreColumna1, no aplica) AS nombreColumna1 , nombrecolumna2
                    FROM public.nombreTabla
                    WHERE id = 1;

    - NULLIF                -> Permite comparar 2 valores y retornar NULL si son iguales

            SELECT NULLIF (0,0);

    - GREATEST              -> Permite comparar un areglo de valores y retorna el mayor

            SELECT GREATEST (1,32,2,23,21,11,123);

    - LEAST                 -> Permite comparar un areglo de valores y retorna el menor 

            SELECT LEAST (1,32,2,23,21,11,123);

    - BLOQUES ANONIMOS      -> Permite ingresar condicionales pero dentro de una consulta de 
                               base de datos 
            
            SELECT id COALESE (nombreColumna1, no aplica) AS nombreColumna1 , nombrecolumna2 , fecha_nacimiento
                    CASE 
                    WHERE fecha_nacimiento > '2015-01-01' THEN
                    'niño'
                    ELSE 
                    'Mayor'
                    END
                    FROM public.nombreTabla;

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Vistas 
    - Volatil                       -> Siempre que se haga la consulta la base de datos va a hacer 
                                       la ejecucion de la consulta en la base de datos por lo cual 
                                       siempre va ha tener informacion reciente
    - Materializada: Persistente    -> solamente hace la consulta una vez y la informacion queda 
                                       guardada en memoria la siguiente vez que consultes la va ha 
                                       traer de memoria (si no actualiza la vista podra traer datos 
                                       viejos o inservibles)

    Creacion Vista Volatil
        - Buscamos views
        - Click derecho -> Create -> view
            - General
                - Name (NombreVista)
            - code 
                - Copiamos lo que queramos que sea la vista

        Consultarla
            SELECT * FROM NombreVista;

    Creacion vista Materializada
        - Buscamos Materialized views 
        - click derecho -> Create -> Materialized view 
            - General
                - Name (NombreVista_mview)
            - Definition
                - Copiamos la consulta 
            - Storage
                - With data                 -> Si queremos llenar la vista cuando la estamos creando o no

        Para llenarla de datos 
            REFRESH MATERIALIZED VIEW NombreVista_mview;
            
        Consultarla 
            SELECT * FROM NombreVista_mview;

///////////////////////////////////////////////////////////////////////////////////////////////////////////

PL/SQL 
    PL (Procedimientos almacenados)

    Estructura Basica
        [<<>label>>]
        [DECLARE
            declarations]
        BEGIN
            statements
        END[label];

    - Muestra un mensaje en consola 
        DO $$
        BEGIN
            RAISE NOTICE 'Algo esta pasando';
        END
        $$

    - Declaramos una variable
        DO $$
        DECLARE
        rec recor;
        contador integer := 0;
        BEGIN
        FOR rec IIN SLECT * FROM nombreTabla LOOP
            rec.nombreColumna
            RAISE NOTICE 'El dato de la variable es %', rec.nombreColumna;
            contador := contadro + 1;
        END LOOP;
        RAISE NOTICE 'El contero es %', contador;
        END
        $$

    Funciones Estructura
        CREATE OR REPLACE FUNCTION nombreFuncion()
        RETURN TipoDatoOVoid
        AS 
            statements
        LANGUAGE lenguaje;
    
    Ejemplo
        CREATE OR REPLACE FUNCTION nombreFuncion 
        RETURN integer
        AS $$
        DECLARE
        rec recor;
        contador integer := 0;
        BEGIN
        FOR rec IN SLECT * FROM nombreTabla LOOP
            rec.nombreColumna
            RAISE NOTICE 'El dato de la variable es %', rec.nombreColumna;
            contador := contadro + 1;
        END LOOP;
        RAISE NOTICE 'El contero es %', contador;
        RETURN contador;
        END
        $$
        LANGUAGE PLPGSQL;


    Tipos de datos 
        record      -> Permite almacenar datos de una fila 

    Para inicializar una variable 
        variable tipoVar := valores  

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Creacion de funciones en PgAdmin
    - Buscamos funciones
    - Click derecho -> Create -> Function 
        - General
            - Name (nombreFuncion)
        - Definition
            - Return type   (cambiamos el valor de retorno)
            - Lenguaje      (Cambiamos al lenguaje que estamos utilizando)
        - Code
            - Colocamos el bloque de codigo que queremos insertar
        - Options
            - Volatility                -> Mantener ne cache la funcion 
            - Returns a set             -> Retorna un areglo de datos
            - Strict                    -> Si la PL esta verificando que los parametros no vengan NULL
            - Security of Defender      -> Si solamete lo pueda ejecutar el creador
            -Window                     -> si lo ejecutamos en un hilo aparte 
            - 

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Triggers 
    Tambien conocidos como "Disparadores"
        Permiten ejecutar funciones dependiendo de acciones que se ejecuten sobre una tabla cuando pasan 
        una de estas acciones (Insert - Update - Delete) 
    
    - Creacion de bitacora 
        - Creamos una tabla (total - integer , tiempo - time , id - serial)
        - Modifucamos la pl 
            
            INSERT INTO Nombre_tabla (valores de las columnas)
            VALUES (valores)

    - Ejemplo 
        CREATE OR REPLACE FUNCTION nombreFuncion 
            RETURN TRIGGER 
            AS $$
            DECLARE
            rec recor;
            contador integer := 0;
            BEGIN
            FOR rec IN SLECT * FROM nombreTabla LOOP
                rec.nombreColumna
                RAISE NOTICE 'El dato de la variable es %', rec.nombreColumna;
                contador := contadro + 1;
            END LOOP;
            INSERT INTO Nombre_tabla (total, tiempo)
            VALUES (contador, now() )
            RETURN NEW;
            END
            $$
            LANGUAGE PLPGSQL;
    
    - Creamos un Trigger
        CREATE TRIGGER nombre_triger
            AFTER INSERTON public.nombreTabla       --Nombre de la tabla a la que queremos crear el control 
                                                      de INSERT - DELETE - UPDATE
            FOR EACH ROW
            EXECUTE PROCEDURE public.nombrePl();    --Nombre del pl al cual esta vinculado el Trigger  
                                               
///////////////////////////////////////////////////////////////////////////////////////////////////////////

Obtener datos de host remotos
    - Verificar si la funcion de dbLink() esta activa
    
    - Creamos la exrencion de dbLink
        CREATE Extension dbLink;     
    
    - Como conectarse     
        - Select * from 
          dbLink('dbname = nombreBasedatos
                port = 5432
                host = id del equipo 
                user = con el que vamos a acceder
                password = contraseña del usuario',
                'SELECT id , nombreColumna, nombreColumna1' FROM nombreTabla) Consulta
                AS nombreTabla (id integer, nombreColumna tipo, nombreColumna1 tipo );    
    
    - Como conectarse con una tabla local 
        - Select * from Nombre_tabla
        JOIN 
           dbLink('dbname = nombreBasedatos
                port = 5432
                host = id del equipo 
                user = con el que vamos a acceder
                password = contraseña del usuario',
                'SELECT id , nombreColumna, nombreColumna1' FROM nombreTabla) Consulta
                AS nombreTabla (id integer, nombreColumna tipo, nombreColumna1 tipo )
        USING (id);     si esta repedida en los 2 campos o ON (pasajeros.id = datos_remotos.id);
    
    - Como conectarse de una tabla local a una remota
        - Select * from Nombre_tabla
        RIGHT JOIN 
           dbLink('dbname = nombreBasedatos
                port = 5432
                host = id del equipo 
                user = con el que vamos a acceder
                password = contraseña del usuario',
                'SELECT id , nombreColumna, nombreColumna1' FROM nombreTabla) Consulta
                AS nombreTabla (id integer, nombreColumna tipo, nombreColumna1 tipo )
        USING (id)
        WHERE nombreTabla IS NULL;

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Transacciones
    - Sirve para crear un bloque de consultas que todas las tareas se ejecuten correctamente  
        - Estructura
            BEGIN
            <Consulta>
            COMMIT | ROLLBACK

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Otras extenciones para postgres     https://www.postgresql.org/docs/11/contrib.html
    - Buscamos en la pagina de postgresql si la extencion esta instalada  y si esta creamos la 
      extencion copn el nombre de lña carpeta donde esta (F.15. fuzzystrmatch)
            CREATE EXTENSION fuzzystrmatch
    
    - Para comparar 2 palabras y mostrar la cantidad de letras que toca cambiar para que sean iguales      
        SELECT levenshtein ('palabra1','palabra2')  
    
    - Compara 2 palabras que cuando se pronuncian en ingles suenan parecidas de 0 a 4 que tan 
      similares son 
        SELECT difference ('palabra1','palabra2') 

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Backups y Restauracion 
    - Click derecho en la base de datos 
    - Backup 
        - General 
            - Filename              (Nombre del archivo del Backup)
            - Format                (Formato del Backup)
                - Custom        -> Es un formato unico que usa postgres para guardar informacion 
                                   de la base de datos solo, se puede utilizar con PgAdmin
                - Tar           -> Es uin archivo coimprimido que tiene la estructura de la base de datos 
                - Plain         -> Es SQL plano, tendra los CREATE, INSERT. Es una gran 
                                   consulta de bases de datos
                - Directory     -> Tiene la estructura sin comprimir de la base de datos 
            - Compression ratio    (Es la cantidad de veces que el ciclo de compresion se 
                                   ejecuta sobre el archivo para que el archivo sea mas pequeño (NO TOCAR))
            - Encording             (Codificacion)
            - Number of jobs        (Asigna la cantidad de hilos del procesador)
            - Role name             (quien va ha ser el dueño de ese dump)
            - ... Cambiamos el lugar de donde guardamos la base de datos 
        
        - Dump options ( Darle en el signo ? para tener mas detalles)
            - Selections
                - Pre-data      ()
                - Post-data     ()
                - Data          ()
    
            - Type of objects 
                - Only data     () 
                - Only schema   ()
                - Blobs         (Son un tipo de datos que no son binarios (No es recomendable))
            - Do not save
                - Owner                 ()
                - Privilege             ()
                - Tablespace            ()
                - Unlogged table data   ()
                - Commets               ()

    - Para Restauracion
        - Creamos una nueva base de datos 
        - Click Restart

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Mantenimiento 
    Se pudede hacer a nivel de bases de datos como a nivel de tablas (son muy diferentes)

    - Click derecho -> Maintenance 
         - Obtions
            - Maintenance operation 
                - VACUUM        (Vaciar)
                    - FULL          (Revisa todas las tablas en memoria)
                    - FREEZE        (Se congela mientras hace la limpieza)
                    - ANALYZE       (Ejecuta una revision y no hace cambios)
                - ANALYZE       (No hace ningun cambio a la tabla )
                - REINDEX       ()
                - CLUSTER       (Reorganiza la informacion en el disco)
            - Verbose Messages  (Muestre en pantalla como le fue a la revision)

///////////////////////////////////////////////////////////////////////////////////////////////////////////

Replicas 
    - Entramos a  https://app.cloudjiffy.co
    - Creamos el servidor Master
        - NEW EVIRONMENT            (para crear una nueva base de datos)
            - Seleccionamos una nueva base de datos
            - Public IPv4 (ON)
            - Environment Name (colocamos nombre de la base de datos master) 

    - Creamosel servidor replica 

        - NEW EVIRONMENT                    (para crear una nueva base de datos)
            - Seleccionamos una nueva base de datos
            - Public IPv4                   (ON)
            - Environment Name              (colocamos nombre de la base de datos Replica)

    DEBE LLEGAR UN CORREO CON EL USUARIO Y CONTRASEÑA DE CADA UNA DE LAS BASES DE DATOS QUE CREEMOS
    LAS CUALES USAREMOS PARA CONECTARNOS CON EL PgAdmin

    - Creamos los 2  servidor en PgAdmin con el mismo nombre que los que creamos anteriormente
    MASTER    
        - Servers 
        - Click derecho -> Server
            - General 
                - Name (Master)
                - Server group (Servers)
            - Connection
                - Host name / adderss (Copiamos la segunda ip )
                - Username (Usuario que llego al correo de confirmacion)
                - Password (Contraseña que llego al correo de confirmacion)

    REPLICA
        - Servers 
        - Click derecho -> Server
            - General 
                - Name (Master)
                - Server group (Servers)
            - Connection
                - Host name / adderss (Copiamos la segunda ip)
                - Username (Usuario que llego al correo de confirmacion)
                - Password (Contraseña que llego al correo de confirmacion)

    -------------------------------------------------------------------------------------------------------
    
    Configuracion de el servidor  (Master)
    - Colocamos el raton encima de Node id
    - Damos click en config
    - Buscamos el archivo postgresql.conf
        - Cambiamos los siguentes cambios quitamos #
            - wal_level = hot_standby
            - max_wal_senders = 2                   -- Es la cantidad de replicas que vamos a tener
            - archive_mode = on                     -- No va a eliminar los archivos sino que los va ha 
                                                       archivar
            - archive_command = 'cp %p /tmp/%f '
            - save 

        - Buscamos el archivo pg_hba.conf
            - Agregamos 
                host        replication         all        primer_ip_replica/32     trust 

    - Reiniciamos el sevicio     
    - Colocamos el raton encima de Node id
    - Damos click en Restart Nodes

    *******************************************************************************************************
    Configuracion de el servidor  (Replica)
    - Colocamos el raton encima de Node id
    - Damos click en Statics                -- Activa una consola
        - sudo service postgresql stop
        - rm -rf /var/lib/pgsql/data/*
        - pg_basebackup -U nombreUsuario -R -D /var/lib/pgsql/data/ --host=primer_ip_master --port=5432 

    - Vamos a SQL Databases : Confings
        - Buscamos el archivo postgresql.conf
        - Cambiamos los siguentes cambios quitamos #
            - hot_standby = on 
        - Save 

    - sudo service postgresql start

    - Vamos a PgAdmin
    - Nos desconectamos del servidor de replica y nos volvemos a conectar
    - nos toca colocar la cotraseña de Master  

    EN LA RAMA MASTER YA PODEMOS CREAR BASES DE DATOS NORMALES 
///////////////////////////////////////////////////////////////////////////////////////////////////////////

Para saber el formato de del dato date 
    SELECT current_date;

Para crear datos aleatorios 
    https://mockaroo.com
